#https://github.com/cocaman/malware-bazaar/blob/master/bazaar_download.py

import argparse
import csv
import requests
import concurrent.futures
import logging
import sys

CSV_PATH = '../sha256/'
MALWARE_PATH = '../../DataSet/malware/'

sha256 = []

logging.basicConfig(
    format='%(asctime)s - %(levelname)s: %(message)s',
    datefmt='%H:%M:%S',
    level=logging.INFO
    )

def read_csv(csv_name):
    with open(CSV_PATH + csv_name, mode='r')as file:
        csvFile = csv.reader(file)
        for line in csvFile:
            sha256.append(line)

def check_sha256(s):
    if s == '':
        return False
    if len(s) != 64:
        logging.warning(f'Please use sha256 value instead of {s}')
        return False
    return True

def remove_downloaded_values():
    with open(CSV_PATH + csv_file, "w") as file:
        for val in sha256:
            file.write(f'"{val[0]}"\n')

def download_file(hash):
    data = {
        'query': 'get_file',
        'sha256_hash': hash,
    }

    try:
        response = requests.post('https://mb-api.abuse.ch/api/v1/', data=data, allow_redirects=True)
    except requests.Timeout:
        logging.error('request timed out')
    if 'file_not_found' in response.text:
        logging.error('file not found')
        return
    if 'error' in response.text:
        logging.error(f'response error: {response.text}')
        remove_downloaded_values()
        return False
    open(MALWARE_PATH + hash + '.zip', 'wb').write(response.content)
    logging.info(f'sample_downloaded: {hash}')
    sha256.remove(hash)
    return True

parser = argparse.ArgumentParser(description='Download a list of malware samples from Malware Bazaar by abuse.ch')
parser.add_argument('-s', '--csv', help='path to csv file with sha256-hashes of malware to be downloaded', required=True)
csv_file = parser.parse_args().csv

logging.info(f'start downloading {csv_file}')

read_csv(csv_file)
valid_sha256 = [key[0] for key in sha256 if check_sha256(key[0])]

error_occured = False

with concurrent.futures.ThreadPoolExecutor() as executor:
    futures = [executor.submit(download_file, hash) for hash in valid_sha256]
    for future in concurrent.futures.as_completed(futures):
        if not future.result():
            error_occured = True
            break

if error_occured:
    sys.exit(0)

logging.info('done')
