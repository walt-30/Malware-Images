#https://github.com/cocaman/malware-bazaar/blob/master/bazaar_download.py

import argparse
import csv
from threading import Event
import requests
import concurrent.futures
import logging

CSV_PATH = '../sha256/'
MALWARE_PATH = '../../DataSet/malware/'

successful_sha256 = []
error_occured = Event() # False by default

logging.basicConfig(
    format='%(asctime)s - %(levelname)s: %(message)s',
    datefmt='%H:%M:%S',
    level=logging.INFO
    )

def read_csv(csv_name):
    sha256 = []
    with open(CSV_PATH + csv_name, mode='r')as file:
        csvFile = csv.reader(file)
        for line in csvFile:
            sha256.append(line)
    return sha256

def check_sha256(s):
    if s == '':
        return False
    if len(s) != 64:
        logging.warning(f'Please use sha256 value instead of {s}')
        return False
    return True

def download_file(hash, error_occured):
    if error_occured.is_set():
        return
    data = {
        'query': 'get_file',
        'sha256_hash': hash,
    }

    try:
        response = requests.post('https://mb-api.abuse.ch/api/v1/', data=data, allow_redirects=True)
    except requests.Timeout:
        logging.error('request timed out')
    if 'file_not_found' in response.text:
        logging.error('file not found')
        return
    if 'error' in response.text:
        logging.error(f'response error: {response.text}')
        error_occured.set()
        return
    open(MALWARE_PATH + hash + '.zip', 'wb').write(response.content)
    logging.debug(f'sample_downloaded: {hash}')
    successful_sha256.append(hash)

def remove_downloaded_values():
    failed_sha256 = filter(lambda key : key not in successful_sha256, VALID_SHA256)
    with open(CSV_PATH + csv_file, "w") as file:
        for val in failed_sha256:
            file.write(f'"{val}"\n')

parser = argparse.ArgumentParser(description='Download a list of malware samples from Malware Bazaar by abuse.ch')
parser.add_argument('-s', '--csv', help='path to csv file with sha256-hashes of malware to be downloaded', required=True)
csv_file = parser.parse_args().csv

logging.info(f'start downloading {csv_file}')

SHA256 = read_csv(csv_file)
VALID_SHA256 = [key[0] for key in SHA256 if check_sha256(key[0])]

with concurrent.futures.ThreadPoolExecutor() as executor:
    futures = [executor.submit(download_file, hash, error_occured) for hash in VALID_SHA256]
    for future in concurrent.futures.as_completed(futures):
        logging.info(f'future.result is {future.result()}')

wait_result = concurrent.futures.wait(futures)

remove_downloaded_values()

logging.info('done')
