#https://github.com/cocaman/malware-bazaar/blob/master/bazaar_download.py

import argparse
import csv
import requests
import concurrent.futures
import logging

CSV_PATH = '../sha256/'
MALWARE_PATH = '../../DataSet/malware/'

sha256 = []


logging.basicConfig(
    filename='../../bazaar_download.log',
    filemode='w',
    format='%(message)s',
    level=logging.critical
    )

def read_csv(csv_name):
    with open(CSV_PATH + csv_name, mode='r')as file:
        csvFile = csv.reader(file)
        for line in csvFile:
            sha256.append(line)

def check_sha256(s):
    if s == '':
        return False
    if len(s) != 64:
        logging.warning(f'Please use sha256 value instead of {s}')
        return False
    return True

def download_file(hash):
    data = {
        'query': 'get_file',
        'sha256_hash': hash,
    }

    try:
        response = requests.post('https://mb-api.abuse.ch/api/v1/', data=data, allow_redirects=True)
    except requests.Timeout:
        logging.error('request timed out')
        logging.critical(f'"{hash}",')

    if 'file_not_found' in response.text:
        logging.error('file not found')
        logging.critical(f'"{hash}",')
        return
    if 'error' in response.text:
        print('response_error')
        logging.error(f'response error: {response.text}')
        logging.critical(f'"{hash}"')
        return
    open(MALWARE_PATH + hash + '.zip', 'wb').write(response.content)
    logging.info(f'sample_downloaded: {hash}')
    print(f'Sample {hash} downloaded.')


parser = argparse.ArgumentParser(description='Download a list of malware samples from Malware Bazaar by abuse.ch')
parser.add_argument('-s', '--csv', help='path to csv file with sha256-hashes of malware to be downloaded', required=True)
csv_file = parser.parse_args().csv

logging.info(f'start downloading {csv_file}')

read_csv(csv_file)
valid_sha256 = [key[0] for key in sha256 if check_sha256(key[0])]

with concurrent.futures.ThreadPoolExecutor() as executor:
    futures = [executor.submit(download_file, hash) for hash in valid_sha256]
    for future in concurrent.futures.as_completed(futures):
        print(future.result())

logging.info('done')
print('done')
